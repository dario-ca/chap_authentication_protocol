#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------



\usepackage{lipsum}% 

% Use the Palatino font
% Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype}% Slightly tweak font spacing for aesthetics

% Document margins
\usepackage{multicol}% Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}% Custom captions under/above floats in tables or figures
% Horizontal rules in tables
% Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
% For hyperlinks in the PDF

\usepackage{lettrine}% The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist}% Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract}% Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec}% Allows customization of titles
\renewcommand{\thesection}{\Roman{section}} % Roman numerals for the sections
\renewcommand{\thesubsection}{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr}% Headers and footers
 % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{CS 587 $\bullet$ December 2014} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{5mm}\fontsize{24pt}{10pt}\selectfont\textbf{decidere titolo}} % Article title

\author{
\large
\textsc{Bruzzo Paolo, Casula Dario}\\[2mm] % Your name
\normalsize University of Ilinois at Chicago \\ % Your institution
\normalsize \href{}{\{pbruzz2,dcasul3\}@uic.edu} % Your email address
\vspace{-5mm}
}


%----------------------------------------------------------------------------------------
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding T1
\font_roman palatino
\font_sans default
\font_typewriter mathpazo
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\columnsep 20pt
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{fancy}
\end_layout

\end_inset

 
\end_layout

\begin_layout Abstract
\noindent
This document describes how to implement a secure and continuous host authentica
tion in a client-server architecture (also extendible to a host to host
 authentication), through the periodic exchange of unique and non-predictable
 challenges (or tokens).
 This Point-to-Point Challenges Handshake Protocol (CHAP) provides protection
 against Replay Attacks.
 The implementations of the client and the server have been made using Python
 programming language.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

2
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lettrine
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


A
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

uthentication is a procedure that confirms the truth of an entity which
 intends to perform a given operation.
 Usually authentication is performed through the exchange of a common secret.
 That is the core principle of a standard password authentication protocol.
 This type of protocol is vulnerable to the replay attack in which a valid
 data transmission is maliciously repeated: for instance, by eavesdropping
 the password (or the hash of it) an attacker can impersonate a real user
 and authenticate to the server which, from that moment on, will trust the
 attacker as the impersonated valid user.
 The Challenge-Handshake Authentication Protocol (CHAP) provides protection
 against those attacks: it is used to periodically verify the identity of
 a user using a 3-way handshake, exchanging unique non-predictable session
 tokens.
\end_layout

\begin_layout Section
The Protocol
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lettrine
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

T
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

he protocol is a Point-to-Point Challenge-Handshake authentication protocol
 (CHAP).
 It is used to periodically verify the identity of a user with a 3-way handshake.
 Each handshake uses a unique challenge (session token) to authenticate
 the host.
 The answer of the host is an hashed combination of the challenge received
 and a secret, both the authenticator and host know the plaintext of the
 secret.
 The protocol provides authentication after the link has been already establishe
d.
 The authenticator starts to send a random-generated challenge message to
 the host which appends the secret to the token received and compute the
 hash function of the whole string.
 The host sends this new message to the authenticator that checks this response
 against its own computation of the expected hash value.
 If the two values match the authentication succeeds, otherwise the connection
 is closed.
 The whole procedure, of sending a challenge, replying with the hash and
 checking the response, is performed periodically in order to keep authenticate
 the identity of the host, throughout the entire session of the connection.
 At every cycle of execution of the algorithm, a new different challenge
 is generated, in this way, all the previous responses of the host are no
 more valid, since the final hash calculated will be different.
 In the figure below you can see the steps of the protocol.
\end_layout

\begin_layout Standard

\color red
FIGURA DELL'INIT
\end_layout

\begin_layout Standard
Here we summarize the steps implemented by the protocol:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{compactitem}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
item 
\end_layout

\end_inset

the authenticator sends a "challenge" message to the peer;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
item 
\end_layout

\end_inset

the peer responds with a value calculated using a one-way hash function
 on the challenge and the secret combined;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
item 
\end_layout

\end_inset

the authenticator checks the response against its own calculation of the
 expected hash value; 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
item 
\end_layout

\end_inset

if the values matches, the authenticator acknowledges the authentication,
 otherwise it terminates the connection;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
item 
\end_layout

\end_inset

at random intervals the authenticator sends a new challenge to the host.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{compactitem}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
The Implementation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lettrine
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


A
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 client-server configuration has been implemented using Python programming
 language.
 The server is the authenticator in the CHAP protocol, while the client
 is the host that has to authenticate to the server.
 Both the server and the client has been implemented.
 The server sets up the connection and listen to a port that will be used
 by the client for the authentication.
 Since the protocol implemented provides protections once the link has been
 already established, the server requires the client to insert a secret
 that will be sent after an encoding with SHA2.
 If the hash of the secret matches against the has computed by the server,
 the connection is established.
 The CHAP protocol implement a continuous authentication; cyclically, the
 server send a random-generated challenge to the client, the client append
 the secret and compute the hash of the whole message.
 This message is sent back to the server that checks it and keep the connection
 open if the two messages match.
 The client and the server start a parallel thread to handle the CHAP steps:
 the server second thread sends the challenges while the client second thread
 appends the secret at each handshake, encodes the message and sends it
 back to the server.
 In the meantime, the main threads of the client and the servers exchange
 messages inserted by the user.
 The interval of time between two handshake is not fixed, but chosen randomly
 in a range from 10 to 20 seconds.
 The client has in every moment the possibility to close the connection
 sending a predefined keyword that is recognized by the server.
\end_layout

\begin_layout Standard

\color red
DECIDERE CHE FIGURE METTERE MAGARI DEGLI SCREENSHOTS
\end_layout

\begin_layout Section
The protection
\end_layout

\begin_layout Standard
The Challenge-Handshake Authentication Protocol (CHAP) provides protection
 against Replay Attacks that imply eavesdropping.
 In the traditional password authentication method, the connection is based
 on a one-time-inserted secret that is no more checked throughout all the
 connection.
 If an attacker succeeds in eavesdropping the secret of the user (or even
 the hash sent), he/she is able to impersonate the valid user and substitute
 it in the communication with the server.
 The CHAP protocol avoids this kind of attack, since it is not possible
 to retrieve the secret, indeed, the message sent by the client is not the
 hash of the password, but the hash of a combination between the password
 and a one-time random generated token.
 The plaintext of the secret is known only by the valid client and the server.
 In the figure below we can anlyze how a eavesdropping attack is avoided
 by the CHAP protocol.
\end_layout

\begin_layout Standard

\color red
FIGURA EAVESDROPPING 1
\end_layout

\begin_layout Standard
The client sends to the server the hash of the secret.
 This hash is successfully intercepted by Eve, who wants to impersonate
 the client.
 The protocol implemented avoid the attack because Eve cannot reply successfully
 to the request of a challenge sent by the server: the correct answer is
 the hash of a combination of the challenge sent and the plain text of the
 password, that never is sent on the network.
 The attacker cannot in this way act on behalf of the client.
\end_layout

\begin_layout Standard
A second example of a possible eavesdropping attack is reported in the next
 figure.
\end_layout

\begin_layout Standard

\color red
FIGURA EAVESDROPPING 2
\end_layout

\begin_layout Standard
In the figure, Eve succesfully eavesdropped the answer the client gives
 to a challenge.
 Also in this second example, Eve cannot reply to the next challenge, since
 the next token is new and random-generated.
 Again, the attack is prevented because there is no way to know the secret
 of the user.
 When a token changes over time into an always new one, it 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
